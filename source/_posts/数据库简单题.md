---
title: 数据库简答题
abbrlink: 7c636df1
date: 2019-03-23 22:27:53
tags:
---

# 数据库简答题

## 试述数据、数据库、数据库管理系统、数据库系统的概念。

**数据**： 描述事物的符号记录称为数据。数据的种类有文字、图形、图象、声音、正文等等。数据与其语义是不可分的。
**数据库**： 数据库是长期储存在计算机内、有组织的、可共享的数据集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享。
**数据库系统**： 数据库系统（DBS）是指在计算机系统中引入数据库后的系统构成。数据库系统由数据库、数据库管理系统（及其开发工具）、应用系统、数据库管理员构成。
**数据库管理系统**： 数据库管理系统(DBMS)是位于用户与操作系统之间的一层数据管理软件。用于科学地组织和存储数据、高效地获取和维护数据。DBMS主要功能包括数据定义功能、数据操纵功能、数据库的运行管理功能、数据库的建立和维护功能。

## 试述文件系统与数据库系统的区别和联系。

**区别**：
**文件系统**面向某一应用程序，共享性差、冗余度大，独立性差，纪录内有结构、整体无结构，应用程序自己控制。
**数据库系统**面向现实世界，共享性高、冗余度小，具有高度的物理独立性和一定的逻辑独立性，整体结构化，用数据模型描述，由数据库管理系统提供数据安全性、完整性、并发控制和恢复能力。

**联系**：
文件系统与数据库系统都是计算机系统中管理数据的软件。

## 试述概念模型的作用。

概念模型实际上是现实世界到机器世界的一个中间层次。概念模型用于信息世界的建模，是现实世界到信息世界的第一层抽象，是数据库设计人员进行数据库设计的有力工具，也是数据库设计人员和用户之间进行交流的语言。

## 试述数据模型的组成要素

数据结构
数据操作
数据的完整性约束条件

## 基本关系的性质

列同质，来自同一个域
不同的列可能来自同一个域
列的顺序无所谓
任意两个候选码不能取相同的值
行的顺序无所谓
分量必须取原子值

## 定义并解释概念模型中以下术语：

**实体**：客观存在并可以相互区分的事物叫实体。
**实体型**：具有相同属性的实体具有相同的特征和性质，用实体名及其属性名集合来抽象和刻画同类实体称为实体型。
**实体集**：同型实体的集合称为实体集。
**属性**：实体所具有的某一特性，一个实体可由若干个属性来刻画。
**码**：唯一标识实体的属性集称为码。
**实体联系图**：E-R图提供了表示实体型、属性和联系的方法：
**实体型**：用矩形表示，矩形框内写明实体名。
**属性**：用椭圆形表示，并用无向边将其与相应的实体连接起来。
**联系**：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来

## 简述数据库系统的三级模式结构和两级映像。

从数据库管理系统的角度看，数据库系统的结构通常分为三级模式的总体结构，在这种模式下，形成了二级映像，实现了数据的独立性。

其中**三级模式**结构指的是外模式、模式和内模式，**二级映**像指的是外模式/模式映像、模式/内模式映像。

**模式**也称逻辑模式和概念模式，是数据库中全体数据逻辑结构和特征的描述，描述现实世界中的实体及其性质与联系，是所有用户的公共数据视图；**外模式**也称子模式或用户模式，它是用以描述用户看到或使用的数据的局部逻辑结构和特性的，用户根据外模式用数据操作语句或应用程序去操作数据库中的数据；**内模式**也称存储模式，是整个数据库的最底层表示，它是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。

对于**外模式/模式映像**，当模式改变时，相应的外模式/模式映像作相应的改变，以使外模式保持不变，而应用程序是依据数据的外模式来编写的，外模式不变，应用程序就没必要修改，这保证了数据与程序的**逻辑独立性**。对于**模式/内模式映像**，当数据库的存储结构变了，模式/内模式映像会作相应的改变，以使模式保持不变，而模式不变，与模式没有直接联系的应用程序也不会改变，这保证了数据与程序的**物理独立性**。

## 数据库系统三级模式结构的优点是什么？

优点：数据库系统的三级模式是对数据的三个抽象级别，它把数据的具体组织留组DBMS管理，使用户能逻辑抽象地处理数据，而不必关心数据在计算机中的表示和存储。

## 什么叫数据与程序的物理独立性？什么叫数据与程序的逻辑独立性？为什么数据库系统具有数据与程序的独立性？

当**模式**改变时（例如增加新的关系、新的属性、改变属性的数据类型等），由数据库管理员对各个**外模式／模式**的映像做相应改变，可以使**外模式保持不变**。应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的**逻辑独立性**。

当数据库的**存储结构**改变了，由数据库管理员对**模式／内模式**映像做相应改变，可以使**模式保持不变**，从而应用程序也不必改变，保证了数据与程序的**物理独立性**，简称数据的物理独立性。

## 关系的完整性有哪些？并用实例解释。

**实体完整性**：主属性不能为空。
例如学生（学号，姓名，性别，专业号，年龄）主属性学号不能为空
**参照完整性** ：若属性（或属性组）F 是基本关系 R 的外码，它与基本关系 S 的主码 Ks 相对应（基本关系 R 和 S 不一定是不同的关系），则对于 R 中每个元组在 F 上的值必须为：取空值（F 的每个属性值均为空值）或者等于 S 中某个元组的主码值。
学生（学号，姓名，性别，专业号，年龄）
专业（专业号，专业名）
**用户定义完整性**  例如某字段的取值在1～100之间

## 实体间的联系有哪些？请举例说明。

1：1  班级和正班长
1：n  班级和学生
M：N  学生和课程

## 数据库设计分为哪几个阶段？

**需求分析**：数据字典。准确了解与分析用户需求（包括数据与处理）。
**概念结构设计**：ER图。通过对用户需求进行综合、归纳与抽象，形成一个独立于具体DBMS的概念模型。
**逻辑结构设计**：关系或非关系模型。将概念结构转换为某个DBMS所支持的数据模型，并对其进行优化。
**物理结构设计**：索引，分区。为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）。
**数据库实施**：设计人员运用DBMS提供的数据语言、工具及宿主语言，根据逻辑设计和物理设计的结果建立数据库，编制与调试应用程序，组织数据入库，并进行试运行。
**数据库运行和维护**：在数据库系统运行过程中对其进行评价、调整与修改。

## 试说明B+树索引和聚簇分别适合用在什么地方？

**B+树索引**适合用于某个值有很少行记录的情况，比如学生表中的学号适合建立B+树索引（同一个值只有一次）
**聚簇**适合于某个值有很多行记录的情况，比如学生表中系别适合建立聚簇。（同一个值出现很多次）

## 什么是数据库系统？

**数据库系统**是实现有组织地、动态地存储大量关联数据，方便多用户访问的计算机软、硬资源组成的系统。它包含关联数据的集合，DBMS和用户应用程序等。

## 简述数据库系统的特点。

**数据结构化**：数据库系统实现整体数据的结构化，这是数据库的主要特征之一，也是数据库系统与文件系统的本质区别。
**数据的共享性高，冗余度低，易扩充**：数据共享可以大大减少数据冗杂。
**数据独立性高**：分为物理独立性和逻辑独立性。
**数据由DBMS统一管理和控制**：DBMS提供一下控制功能：**数据的安全性保护，数据的完整性检查，并发控制，保持数据的一致性，安全保密性，故障恢复**等

## 什么是数据库管理系统？

**数据库管理系统**(DBMS)是操纵和管理数据库的一组软件，它是数据库系统(DBS)的重要组成部分。不同的数据库系统都配有各自的DBMS，而不同的DBMS各支持一种数据库模型，虽然它们的功能强弱不同，但大多数DBMS的构成相同，功能相似。

一般说来，DBMS具有定义、建立、维护和使用数据库的功能，它通常由三部分构成：数据描述语言及其翻译程序、数据操纵语言及其处理程序和数据库管理的例行程序。

## 简述数据库管理系统的功能。

数据定义和创建
数据组织、存储和管理
数据存取
数据库事务管理和运行管理
数据库的建立和维护
数据通信接口。

## 简述SQL语言的特点。

SQL语言集**数据查询**、**数据操纵**、**数据定义**和**数据控制**功能于一体，充分体现了**关系**数据库语言的特点和优点。
其特点如下：
（1）**综合统一**。SQL语言集数据定义语言DDL、数据操纵语言DML、数据控制语言DCL的功能于一体。
（2）**高度非过程化**。用SQL语言进行数据操作，只要提出“做什么”，而无须指明“怎么做”，因此无需了解存取路径，存取路径的选择以及SQL语句的操作过程由系统自动完成。
（3）**面向集合的操作方式**。SQL语言采用集合操作方式，不仅操作对象、查找结果可以是元组的集合，而且一次插入、删除、更新操作的对象也可以是元组的集合。
（4）**以同一种语法结构提供多种使用方式**。SQL语言既是自含式语言，又是嵌入式语言。作为自含式语言，它能够独立地用于联机交互的使用方式，也能够嵌入到高级语言程序中，供程序员设计程序时使用。
（5）**语言简洁，易学易用**。

## 试述数据库完整保护的主要任务和措施。

**主要任务**是保障数据的正确性，有效性，协调性，提高数据对用户的可用性。

**措施**
适时检查完整约束条件，保证语义完整。
控制并发操作，使其不破坏完整性。
在系统出现故障后，即时恢复系统。

## 在倒排文件中，如果只建立了部分关键字的辅索引，如何进行查找？

对询问中涉及的关键字，首先在已建立的辅索引中求指针的交集P，而后对P中所指记录逐个验证其它关键字是否与询问条件匹配，所有匹配的记录即为查询结果。

## 数据库的完整性概念与数据库的安全性概念有什么区别和联系？

**数据的完整性**是为了防止数据库中存在不符合语义的数据，防止错误信息的输入和输出，即所谓垃圾进垃圾出所造成的无效操作和错误结果。

**数据的安全性**是保护数据库防止恶意的破坏和非法的存取。
安全性措施的防范对象是**非法用户和非法操作**，完整性措施的防范对象是**不合语义的数据**。

## 简述嵌入式SQL语句与主语言之间的通信。

首先SQL通信区向主语言传递SQL语句的执行**状态信息**，使主语言能够据此控制程序流程；在程序运行中，主语言向SQL语句提供**参数**，使用主变量输入数据；同时，SQL语句**查询数据库的结果**交给主语言进一步处理，其中使用主变量和游标（cursor）向主语言输出数据，从而实现了SQL语言的过程化工作。

SQL语句执行后，系统要反馈给应用程序若干信息，主要包括描述**系统当前工作状态和运行环境的各种数据**，这些信息将送到**SQL通信区SQLCA**中。应用程序从SQLCA中取出这些状态信息，据此决定接下来执行的语句。

## RDBMS查询优化的一般步骤。（Relational DBMS）

1. 把查询转换成某种内部表示，通常用的内部表示是语法树。
2. 把语法树转换成标准（优化）形式。即利用优化算法，把原始的语法树转换成优化的形式。
3. 选择低层的存取路径。
4. 生成查询计划，选择代价最小的。

## 试述RDBMS查询优化的一般准则。

1. **选择**运算应尽可能先做；
2. 把**投影**运算和**选择**运算同时进行；
3. 把**投影**同其前或其后的双目运算结合起来执行；
4. 把某些**选择**同在它前面要执行的笛卡儿积结合起来成为一个连接运算；
5. 找出公共子表达式；

## 什么是数据库的概念结构？试述其特点和设计策略。

概念结构是信息世界的结构，即概念模型，其主要特点是：

1. 能真实、充分地反映现实世界，包括事物和事物之间的联系，能满足用户对数据的处理要求。是对现实世界的一个真实模型。
2. 易于理解，从而可以用它和不熟悉计算机的用户交换意见，用户的积极参与是数据库的设计成功的关键。
3. 易于更改，当应用环境和应用要求改变时，容易对概念模型修改和扩充。
4. 易于向关系、网状、层次等各种数据模型转换。

概念结构的设计策略通常有四种：

1. 自顶向下。即首先定义全局概念结构的框架，然后逐步细化；
2. 自底向上。即首先定义各局部应用的概念结构，然后将它们集成起来，得到全局概念结构；
3. 逐步扩张。首先定义最重要的核心概念结构，然后向外扩充，以滚雪球的方式逐步生成其他概念结构，直至总体概念结构；
4. 混合策略。即将自顶向下和自底向上相结合，用自顶向下策略设计一个全局概念结构的框架，以它为骨架集成由自底向上策略中设计的各局部概念结构。

## 什么是E-R图？构成E-R图的基本要素是什么？

E-R图为实体-联系图，提供了表示**实体型**、**属性**和**联系**的方法，用来描述现实世界的概念模型。
构成E-R图的基本要素是**实体型、属性和联系**，其表示方法为：
**实体型**：用矩形表示，矩形框内写明实体名；
**属性**：用椭圆形表示，并用无向边将其与相应的实体连接起来；
**联系**：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来。

## 为什么要视图集成？视图集成的方法是什么？

在对数据库系统进行概念结构设计时一般采用自底向上的设计方法，把繁杂的大系统分解子系统。首先设计各个子系统的局部视图，然后通过视图集成的方式将各子系统有机的融合起来，综合成一个系统的总视图。这样设计清晰，由简到繁。

由于数据库系统是从整体角度看待和描述数据的，因此数据不再面向某个应用而是整个系统。因此必须进行视图集成，使得数据库能被全系统的多个用户、多个应用共享使用。

一般说来，视图集成可以有两种方式：

1. 多个分E-R图一次集成；
2. 逐步集成，用累加的方式一次集成两个分E-R图。

无论采用哪种方式，每次集成局部E-R图时都需要分两步走：

1. 合并。解决各分E-R图之间的冲突，将各分E-R图合并起来生成初步E-R图。
2. 修改和重构。消除不必要的冗余，生成基本E-R图。

## 什么是数据库的逻辑结构设计？试述其设计步骤。

数据库的**逻辑结构设计**就是把概念结构设计阶段设计好的基本E-R图转换为与选用的 DBMS 产品所支持的数据模型相符合的逻辑结构。

设计步骤为：

1. 将概念结构转换为一般的关系、网状、层次模型
2. 将转换来的关系、网状、层次模型向特定 DBMS 支持下的数据模型转换
3. 对数据模型进行优化。

## 数据字典的内容和作用是什么？

数据字典是数据库系统中各种**描述信息和控制信息的集合**，它是数据库设计与管理的有力工具，是进行详细数据收集和数据分析所获得的主要成果。

**内容**：数据项，数据结构，数据流，数据存储，处理过程
其中**数据项**是数据的最小组成单位，若干个数据项可以组成一个**数据结构**。数据字典通过对**数据项**和**数据结构**的定义来描述**数据流**和**数据存储**的逻辑内容。

**作用**：数据字典是关于数据库中数据的描述，在需求分析阶段建立，是下一步进行概念设计的基础，并在数据库设计过程中不断修改、充实、完盖。

## 什么是视图，其主要特点是什么？

视图是以现存表的全部或部分内容建立起来的一个表。视图不是物理存在的，它不包含真正存储的数据，不占存储空间。但视图可以像一般的表那样操作，因此视图也称作虚表，而真正物理存在的表称作实表或基本表。

## 视图的作用？

1. 视图能够简化用户的操作。
2. 视图使用户能以多种角度看待同一数据。
3. 视图对重构数据库提供了一定程度的逻辑独立性。即：模式改变，外模式可以不变
4. 视图能够对机密数据提供安全保护。
5. 适时利用试图可以更清晰地表达查询。

## 说明视图与基本表的区别和联系。

视图是从一个或几个基本表导出的表，它与基本表不同，是一个虚表，数据库中只存放视图的定义，而不存放视图对应的数据，这些数据存放在原来的基本表中，当基本表中的数据发生变化，从视图中查询出的数据也就随之改变。

视图一经定义就可以像基本表一样被查询、删除，也可以在一个视图之上再定义新的视图，但是对视图的更新操作有限制。

## 什么是数据管理？其发展经历了哪几个阶段，简要描述各阶段的主要特点。

数据管理是指对数据的**组织、存储、检索和维护**等工作，是数据处理的核心。

数据管理技术随着计算机软件与硬件的发展经历了三个阶段：**人工管理阶段**、**文件系统阶段**和**数据库系统阶段**。

在**人工管理**阶段，没有统一的数据管理软件，对数据的管理完全由各个程序在其程序中进行。
在**文件系统**阶段，部分实现了逻辑数据与物理数据的相互独立性。
在**数据库系统**阶段，完成实现了逻辑数据与物理数据的相互独立，实现了数据共享，具有数据的冗余度小、有利于保证数据的完整性以及实现了对数据的集中管理等许多优点。

## 系统数据库master中记录哪些信息？

记录了SQL Server系统的所有系统信息。这些系统信息包括所有的登录信息、系统设置信息、SQL Server的初始化信息和其它系统数据库及用户数据库的相关信息。

## 什么是索引？建立索引的作用有哪些？索引优缺点

索引是按照一定顺序对表中一列或若干列建立的**列值**与**记录行**之间的**对应关系表**。

**作用**：

1. 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
2. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
3. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
4. 在使用ORDER BY、GROUP BY子句进行数据检索时，利用索引可以减少排序和分组的时间。
5. 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

**缺点**：

1. 创建索引和维护索引要耗费时间，这种时间随着数据 量的增加而增加。
2. 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索3那么需要的空间就会更大。
3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

**适用**：

在经常需要搜索的列上，可以加快搜索的速度；
在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；
在经常用在连接的列上，这 些列主要是一些外键，可以加快连接的速度；
在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；
在经常需要排序的列上创 建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。

## 设计数据库备份策略时的基本思想是什么？

以最小的代价恢复数据

## 存储过程有几类，分别简述各自的特点。

**系统存储过程**由系统自动创建，主要存储在master数据库中，主要功能是从系统表中获取信息，可被其他数据库调用。
**用户自定义存储过程**由用户创建，其主要用于完成某一特定用户要求的功能。

## 数据库系统的故障有哪些类型？

1. 事务故障
2. 系统故障
3. 介质故障

## 数据库对象有表、约束和存储过程等，请简要说明这三个数据库对象的作用。

**表**的作用是存储数据的逻辑结构；
**约束**的作用是自动保持数据库的完整性；
**存储过程**的作用是存储一段实现某个特定任务的代码，以便多次调用。

## DBA的职责是什么？

决定数据库中的信息内容和结构
决定数据库的存储结构和存取策略
定义数据的安全性要求和完整性约束条件
监控数据库的使用和运行
数据库的改进和重组重构。

## 数据库安全性控制

1. 用户标识与鉴别
2. 存取控制
    2.1 自主存取控制方法
    2.2 授权与回收
    2.3 数据库角色
    2.4 强制存取控制方法
3. 视图机制：为不同的用户定义视图，通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动地对数据提供一定程度的安全保护。
4. 审计：建立审计日志，把用户对数据库的所有操作自动记录下来放入审计日志中， DBA可以利用审计跟踪的信息，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等。
5. 数据加密：对存储和传输的数据进行加密处理，从而使得不知道解密算法的人无法获知数据的内容。

## 什么是数据库中的自主存取控制方法和强制存取控制方法？

**自主存取控制**方法：定义各个用户对不同数据对象的存取权限。当用户对数据库访问时首先检查用户的存取权限。防止不合法用户对数据库的存取。

**强制存取控制**方法：每一个数据对象被（强制地）标以一定的密级，每一个用户也被（强制地）授予某一个级别的许可证。系统规定只有具有某一许可证级别的用户才能存取某一个密级的数据对象。

## 数据库的完整性概念与数据库的安全性概念有什么区别和联系

**完整性**是为了防止数据库中存在不符合语义的数据，防止错误信息的输入和输出，即所谓垃圾进垃圾出（Garbage In Garbage Out）所造成的无效操作和错误结果。

**安全性**是保护数据库防止恶意的破坏和非法的存取。

**安全性**措施的防范对象是非法用户和非法操作，**完整性**措施的防范对象是不合语义的数据。

## 关系系统中，当操作违反实体完整性、参照完整性和用户定义的完整性约束条件时，一般是如何分别进行处理的？

对于违反**实体完整性和用户定义的完整性**的操作一般都采用**拒绝**执行的方式进行处理。而对于违反**参照完整性**的操作，并不都是简单地拒绝执行，有时要根据应用语义执行一些**附加的操作**，以保证数据库的正确性。

## 可串行化调度

多个事务的并发执行是正确的，当且仅当其结果与按某一次串行地执行这些事务的结果相同。

## 什么是事务，事务有哪些特性？

**事务**是DBMS的基本工作单位，它是用户定义的一个数据库操作序列。它是一个不可分割的工作单位，这些操作要么都执行，要么都不执行。

事务具有4个特性：
**原子性**（Atomicity）事务是数据库的逻辑工作单位，事务中包括的诸操作要么都做，要么都不做。
原子性是由DBMS的事务管理子系统实现的。
事务的原子性保证了DBS的完整性。

**一致性**（consistency）事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。
事务的一致性是由DBMS的完整性子系统实现的。
事务的一致性保证数据库的完整性。

**隔离性**(Isolation）一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰。
事务的隔离性是由DBMS的并发控制子系统实现的。
隔离性使并发执行的事务不必关心其他事务，如同在单用户环境下执行一样。

**持续性**（Durability）持续性也称永久性（Permanence)，指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其执行结果有任何影响。
持久性是由DBMS的恢复管理子系统实现的。
持久性能保证DB具有可恢复性。

## 事务中的提交和回滚是什么意思？

事务中的**提交**(COMMIT)是提交事务的所有操作。具体说就是将事务中所有对数据库的更新写回到磁盘上的物理数据库中去，事务正常结束。
事务中的**回滚**(ROLLBACK)是数据库滚回到事务开始时的状态。具体地说就是，在事务运行的过程中发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已完成的更新操作全部撤消，使数据库回滚到事务开始时的状态。

## 什么是日志文件？简述事务故障时恢复策略。

日志文件是用来记录事务对数据库的更新操作的文件。

用日志文件恢复事务，即事务故障的恢复的过程如下：

1. 反向扫描文件日志（从最后向前扫描日志文件），查找该事务的更新操作。
2. 对该事务的更新操作执行逆操作。即将日志记录中“更新前的值”写入数据库。如果日志记录中是插入操作，则做删除操作；若日志记录中是删除操作，则做插入操作；若是修改操作，则用修改前值代替修改后值。
3. 继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。
4. 如此处理下去，直至读到此事务的开始标志，事物故障就恢复完成了。

## 简述系统故障时恢复策略。

1. 正向扫描日志文件，找出在故障发生前已经提交的事务，将其事务标识记入 REDO 队列。同时找出故障发生时尚未完成的事务，将其事务标识记入 UNDO 队列。
2. 对 UNDO 队列中的各个事务进行撤销处理。
3. 对 REDO 队列中的各个事务进行重做处理。

## 简述日志文件的内容。

日志文件是用来记录事物对数据库的更新操作的文件，分为**以记录单位的日志文件**和**以数据块为单位的日志文件**。

## 为什么要设立日志文件？

设立日志文件的目的，是为了记录对数据库中数据的每一次更新操作。从而DBMS可以根据日志文件进行事务故障的恢复和系统故障的恢复，并可结合后援副本进行介质故障的恢复。

## 日志文件的作用

1. 事务故障恢复和系统故障恢复
2. 动态转储
3. 静态转储中用来恢复到当前状态

## 登记日志文件时必须遵循什么原则？

1. 登记的次序严格按并发事务执行的时间次序。
2. 必须先写日志文件，后写数据库。

## 数据库恢复的基本原则是什么？具体实现方法是什么？

**基本原则**：数据库的重复存储
**具体实现方法**：
①、转储和建立日志
②、数据恢复

## 简述封锁的概念以及基本的封锁类型

封锁的概念：事务T在对某个数据对象操作之前，先向系统发出请求，对其加锁，加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其他的事务不能更新此数据对象。

基本的封锁的类型有排它锁(“X”锁)和共享锁(“S”锁)两种。
若事务T对数据A加上X锁，则只允许事务T读取和修改数据A，其他事务都不能再对A加任何类型的锁，直到T释放A上的锁。
若事务T对数据A加上S锁，则其他事务可以再对A加S锁，而不能加X锁，直到T释放A上的锁。

## 什么是封锁协议？简述不同级别的封锁协议的主要区别。

封锁协议的**定义**：在运用X锁和S锁对数据对象加锁时，需要约定一些规则，这些规则为封锁协议
主要区别：

1. 一级封锁协议：事务T在修改数据R之前必须先对其加**排他锁X**，直到**事务结束**才释放。它防止了丢失更新问题，但不能保证不读“脏”数据和不可重读。
2. 二级封锁协议：**一级封锁协议**加上事务T在读取数据R之前必须先对其**加S锁**，**读完后**即可释放S锁。它防止丢失更新问题，也进一步防止读“脏”数据，但不能解决不可重读问题。
3. 三级封锁协议：**一级封锁协议**加上事务T在读取数据R之前必须先对其**加S锁**，直到**事务结束**才释放。它防止了丢失更新问题、读“脏”数据，以及不可重读问题。

## 并发操作可能会产生哪几类数据不一致性？分别用什么方法可以避免各种不一致的情况？

1. 丢失修改：采用一级封锁协议解决
2. 读脏数据：采用二级封锁协议解决
3. 不可重复读：采用三级封锁协议解决

**丢失更新 < 读脏数据 < 不可重读**
**easy < hard**

## 什么是“脏”数据？如何避免读取“脏”数据？

“脏”数据**定义**：不正确的临时值
如何避免：采用二级封锁协议或者三级封锁协议

## 并发控制的主要技术

1. 封锁
2. 时间戳
3. 乐观控制法
4. 多版本并发控制

## 什么是活锁？原因及解决办法。

定义：多个事务申请对数据R申请加锁，而系统随机地加锁，导致某些事务长等待
原因：系统随机地加锁
解决办法：采用“先来先服务”的策略预防活锁的发生

## 什么是死锁？原因及解决办法。

定义：两个或两个以上的事务**互相申请**对方加锁对象的**排它锁X**，造成了循环等待

原因：系统中有两个或两个以上的事务都处于等待状态，并且每个事务都在等待其中另一个事务解除封锁，它才能继续执行下去，结果造成任何一个事务都无法继续执行，这样系统就进入了死锁状态。

解决办法：

1. 死锁的预防：
    1.1 一次封锁法（要求每个事务一次就要将它所需要的数据全部加锁）
    1.2 顺序封锁法（预先规定一个封锁顺序，所有的事务都要按这个顺序实行封锁）
2. 死锁的诊断与解除：超时法、等待图法（T1等待T2，就形成一条有向边，有环则为死锁）
3. 选择一个处理死锁代价最小的事务，将其撤消，释放此事务持有的所有的锁，使其它事务能继续运行下去。

## 两段锁

1. 在对任何数据进行读写操作之前，首先要申请并获得对该数据的封锁
2. 在释放一个封锁之后，事务不再申请和获得任何其他封锁

第一阶段扩展阶段，只申请，不释放
第二阶段收缩阶段，只释放，不申请
两段锁一定可以串行化
与一次封锁法的不同：两段锁不要求一次将所有数据全部加锁，因此可能会发生死锁

## 多粒度封锁

多粒度树，对一个结点加锁意味着对所有后裔节点也加同样类型的锁，分为显示封锁和隐式封锁
意向锁，对任一节点加锁时，对上层节点加意向锁，申请封锁从上而下，释放封锁从下而上

## 解释下列术语的含义

**函数依赖**：设R(U)是属性集U上的一个关系模式，X、Y是U的子集。若对于R(U)上的任意一个可能的关系r，如果r中不存在两个元组，它们在X上的属性值相同，而在Y上的属性值不同，则称“X函数决定Y”或“Y函数依赖X”，记作X→Y。
**平凡函数依赖**：设R(U)是属性集U上的一个关系模式，X、Y是U的子集。若Y是X的子集，则称X→Y为平凡函数依赖。
**非平凡函数依赖**：设R(U)是属性集U上的一个关系模式，X、Y是U的子集。如果X→Y，且Y∉X，则称X→Y为非平凡函数依赖。
**部分函数依赖**：如果X→Y，但不完全函数依赖于X，则称Y对X部分函数依赖。
**完全函数依赖**：在R(U)中，如果X→Y，并且对于X的任何一个真子集X’，都有Y函数不依赖于X’，则称Y完全函数依赖于X。
**传递函数依赖**：在R(U)中，如果X→Y ，Y→Z，且Y∉X，X也不函数依赖于Y，则称Z传递函数依赖于X。
**范式**：关系数据库的关系满足一定的要求，满足不同程度要求的为不同的范式。
**规范化**：一个低一级的关系模式通过模式分解可以转换为若干个高一级范式的关系模式的集合。
**1NF**：如果关系模式R的所有属性均为简单属性，即每个属性都是不可再分的，则称R属于第一范式。
**2NF**：如果关系模式R∈1NF，且每个非主属性都完全依赖于R的码，则称R属于第二范式。
**3NF**：如果关系模式R∈2NF，且每个非主属性都不传递函数依赖于R的候选码，则称R属于第三范式。
**BCNF**：如果关系模式R∈1NF，且对于所有的函数依赖X→Y(Y∉X)，决定因素X都包含了R的一个候选码，则称R属于BC范式。
**多值依赖**：设R(U)是属性集U上的一个关系模式，X、Y、Z是U的子集，并且Z=U-X-Y。关系模式R(U)中多值依赖X→→Y成立，当且仅当对R(U)的任一关系r，给定的一对（x,z）值，有一组Y的值，这组值仅仅决定于x值而与z值无关。
**4NF**：关系模式R<U,F>∈1NF，如果对于R的每个非平凡多值依赖X→→Y(Y∉X)，X都含有码，则称R<U,F>∈4NF。
**最小函数依赖**：函数依赖集F满足以下条件：

1. F中的任何一个函数依赖的右部仅含有一个属性；
2. F中不岑仔这样一个函数依赖X→A，使得F与F-{X→A }等价；
3. F中不存在这样一个函数依赖X→A，X有真子集Z使得F-{X→A }∪{Z→A}与F等价。

**函数依赖保持性**：设p={R1<U1，F1>,R2<U2，F2>,···,Rn<Un,Fn>}是关系模式R{U,F}上的一个分解。若∪Fi  =F ，则称分解p具有函数依赖保持性。
**无损连接性**：设p={R1<U1，F1>,R2<U2，F2>,···,Rn<Un,Fn>}是关系模式R{U,F}上的一个分解。若任何属于R{U,F}的关系r，令r1=πR1(r)，r2=πR2(r)，···，rn=πRn(r)，有r=r1∞r2∞···∞rn成立，则称分解p具有无损连接性。

## 各个范式消除了啥

1. 2NF：消除了非主属性对码的部分函数依赖
2. 3NF：消除了非主属性对码的传递函数依赖
3. BCNF：消除了主属性对码的部分函数依赖和传递函数依赖
4. 4NF：消除了非平凡的非函数依赖的多值依赖

## 什么是范式

范式是符合某一种级别的关系模式的集合。构造数据库必须遵循一定的规则。在关系数据库中，这种规则就是范式。关系数据库中的关系必须满足一定的要求，即满足不同的范式。
目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、Boyce-Codd范式（BCNF）、第四范式（4NF）和第五范式（5NF）。

## 保持无损连接和保持函数依赖

无损分解指的是对关系模式分解时，原关系模型下任一合法的关系值在分解之后应能通过自然联接运算恢复起来。针对的是表，表中的属性用表格法来判断，若有一行全是，则为无损分解
保持函数依赖指的是对关系分解时，原关系的闭包与分解后关系闭包的并集相等。分解后的最小依赖集可以恢复到原来的函数依赖集

## 简述等值连接与自然连接的区别和联系。

**等值连接**是从关系R与S的笛卡尔积中选取A、B属性值相等的那些元组。
**自然连接**是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且要在结果中把重复的属性去掉。即若R和S具有相同的属性组B。

连接运算符是“=”的连接运算称为**等值连接**。它是从关系R与S的广义笛卡尔积中选取A，B属性值相等的那些元组，即等值连接为： R∞S={trts| tr∈R ∧ ts∈S ∧ tr[A]=ts[B]}（A列与B列相等）
**自然连接**是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中把重复的属性列去掉。

## 数据模型的三大要素、关系模型的三个组成部分

数据结构、数据操作、完整性约束。
数据模型
    1. 概念模型
    2. 逻辑模型和物理模型

## 定义并理解下列术语，说明它们之间的联系与区别

**域**：域是一组具有相同数据类型的值的集合。
**元组**：关系中的每个元素是关系中的元组。
**属性**：关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域。由于域可以相同，为了加以区分，必须对每列起一个名字，称为属性（Attribute）。

**候选码**：若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码（Candidate key）。
**主码**：若一个关系有多个候选码，则选定其中一个为主码（Primary key）。
**外部码**：设F是基本关系R的一个或一组属性，但不是关系R的码，如果F与基本关系S的主码Ks相对应，则称F是基本关系R的外部码（Foreign key），简称外码。 基本关系R称为参照关系（Referencing relation），基本关系S称为被参照关系（Referenced relation）或目标关系（Target relation）。关系R和S可以是相同的关系。

## NoSQL和RDBMS的区别

ACID是关系型数据库强一致性的四个要求，而BASE是NoSQL数据库通常对可用性及一致性的弱要求原则，它们的意思分别是
ACID：atomicity, consistency, isolation, durability;
BASE：Basically Available, Soft-state, Eventually Consistent。

NOSQL的特点：

1. 对数据进行划分，通过大量节点的并行处理获得高性能
2. 放松对ACID的一致性约束，接受最终一致性
3. 对各个数据分区进行备份

关系型数据库通常是基于行的表格型存储，而NoSQL系统包括了列式存储（Cassandra）、key/value存储（Memcached）、文档型存储（CouchDB）以及图结构存储（Neo4j）

关系数据库有统一的SQL语言操作接口不同，NoSQL系统通常有自己特有的API接口。

NoSQL系统是被设计用于成百上千台机器的集群中的，而非共享型数据库系统的架构。

NoSQL的优势：

1. 数据模型灵活，支持多样的数据类型
2. 高度拓展性，可以拓展集群的规模

关系型数据库的最大特点就是事务的一致性：关系型数据库读写操作都是事务的，具有ACID的特点，这个特性使得关系型数据库可以用于几乎所有对一致性有要求的系统中，如典型的银行系统。关系型数据库为了维护一致性所付出的巨大代价就是其读写性能比较差，而像微博、facebook这类SNS的应用，对并发读写能力要求极高，关系型数据库已经无法应付，因此，必须用新的一种数据结构存储来代替关系数据库。

关系数据库的另一个特点就是其具有固定的表结构，因此，其扩展性极差，而在SNS中，系统的升级，功能的增加，往往意味着数据结构巨大变动，这一点关系型数据库也难以应付，需要新的结构化数据存储。
于是，非关系型数据库应运而生，由于不可能用一种数据结构化存储应付所有的新的需求，因此，非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。

关系型数据库适合存储结构化数据，如用户的帐号、地址等：这些数据通常需要做结构化查询，比如join，这时候，关系型数据库就要胜出一筹，这些数据的规模、增长的速度通常是可以预期的，保证数据的事务性、一致性要求。

NoSQL适合存储非结构化数据，如发微博、文章、评论，这些数据通常用于模糊处理，如全文搜索、机器学习，这些数据是海量的，而且增长的速度是难以预期的，根据数据的特点，NoSQL数据库通常具有无限（至少接近）伸缩性，按key获取数据效率很高，但是对join或其他结构化查询的支持就比较差

## SQL语句的执行过程

![SQL语句的执行过程](SQLexec.png)

## 索引类别

①　唯一索引：
不允许其中任何两行具有相同索引值的索引。

②　主键索引：
表的某一列或列组合，其值唯一标识表中的每一行，该列或列组合称为表的主键。为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。

③　聚集索引：
聚集索引：聚集索引表示表中存储的数据按照索引的顺序存储。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。
聚集索引实例：字典默认按字母顺序排序，如知道某个字的读音可根据字母顺序快速定位。

非聚集索引：非聚集索引表示数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置，需要查询两个地方才能查找到数据。一个表可以包含多个非聚集索引，可以为查找数据时常用的每个列创建一个非聚集索引。
非聚集索引实例：如需查询某个生僻字，则需按字典前面的索引，如按偏旁进行定位，找到该字对应的页数，再打开对应页数找到该字。

与非聚集索引相比，聚集索引通常提供更快的数据访问速度，但对数据更新影响较大。

## 关系数据库中的关系的含义

关系模式实际上就是记录类型。关系可以表示为关系模式，由组成该关系的属性名、属性来自的域、属性向域的映像集合、属性间数据的依赖关系集合组成。关系模式不涉及到物理存储方面的描述，仅仅是对数据特性的描述。  
关系实质上是一张二维表，表的每一行为一个元组，每一列为一个属性。一个元组就是该关系所涉及的属性集的笛卡尔积的一个元素。关系是元组的集合，因此关系模式必须指出这个元组集合的结构，即它由哪些属性构成，这些属性来自哪些域，以及属性与域之间的映象关系。
其次，一个关系通常是由赋予它的元组语义来确定的。元组语义实质上是一个n目谓词（n是属性集中属性的个数）。凡使该n目谓词为真的笛卡尔积中的元素（或者说凡符合元组语义的那部分元素）的全体就构成了该关系模式的关系。

## 为什么外键要建立索引

如果更新了父表的主键（倘若遵循关系数据库的原则，即主键应当是不可变的，这种情况就很少见），由于外键上没有索引，所以子表会被锁住。
如果删除了父表中的一行，整个子表也会被锁住（由于外键上没有索引）

为子表外键创建索引可以有两个好处：
(1) 避免子表上有 表锁，取而代之的是，数据库会获取索引上的行锁。
(2) 避免子表上的全表扫描。假设删除departments主表id=10的记录，如果employees子表的department_id外键没有索引，那么就会全表扫描employees子表，以确认是否存在department id=10的记录。

当满足以下两个条件时，会获取子表的表锁：
(1) 子表外键不存在索引。
(2) 修改主表的主键(例如，删除一行记录或者修改主键值)或者合并主表的多行记录。向主表插入记录不会获取子表的表锁。
只有当主键值修改完成，子表的表锁才会被放开。

## 什么是视图消解

从数据字典中取出试图的定义，把定义中的子查询与用户的查询结合起来，转换为等价的对基本表的查询，然后再执行修正后的查询

## 数据库分区

数据分区是一种物理数据库的设计技术，它的目的是为了在特定的SQL操作中减少数据读写的总量以缩减响应时间。
分区并不是生成新的数据表，而是将表的数据均衡分摊到不同的硬盘，系统或是不同服务器存储介子中，实际上还是一张表。另外，分区可以做到将表的数据均衡到不同的地方，提高数据检索的效率，降低数据库的频繁IO压力值，分区的优点如下：

1. 相对于单个文件系统或是硬盘，分区可以存储更多的数据；
2. 数据管理比较方便，比如要清理或废弃某年的数据，就可以直接删除该日期的分区数据即可；
3. 精准定位分区查询数据，不需要全表扫描查询，大大提高数据检索效率；
4. 可跨多个分区磁盘查询，来提高查询的吞吐量；
5. 在涉及聚合函数查询时，可以很容易进行数据的合并；

分类
1、水平分区
这种形式分区是对表的行进行分区，通过这样的方式不同分组里面的物理列分割的数据集得以组合，从而进行个体分割（单分区）或集体分割（1个或多个分区）。所有在表中定义的列在每个数据集中都能找到，所以表的特性依然得以保持。
举个简单例子：一个包含十年发票记录的表可以被分区为十个不同的分区，每个分区包含的是其中一年的记录。（朋奕注：这里具体使用的分区方式我们后面再说，可以先说一点，一定要通过某个属性列来分割，譬如这里使用的列就是年份）
2、垂直分区
这种分区方式一般来说是通过对表的垂直划分来减少目标表的宽度，使某些特定的列被划分到特定的分区，每个分区都包含了其中的列所对应的行。
举个简单例子：一个包含了大text和BLOB列的表，这些text和BLOB列又不经常被访问，这时候就要把这些不经常使用的text和BLOB了划分到另一个分区，在保证它们数据相关性的同时还能提高访问速度。
在数据库供应商开始在他们的数据库引擎中建立分区（主要是水平分区）时，DBA和建模者必须设计好表的物理分区结构，不要保存冗余的数据（不同表中同时都包含父表中的数据）或相互联结成一个逻辑父对象（通常是视图）。这种做法会使水平分区的大部分功能失效，有时候也会对垂直分区产生影响。

1. range 基于属于一个给定连续区间的列值，把多行分配给分区
2. hash 基于用户定义的表达式的返回值来进行选择的分区，利用hash函数打散某列使数据均匀分布
3. list 基于列值匹配一个离散值集合中的某个值来进行选择，例如国家名字，按州来分区
4. KEY 分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL 服务器提供其自身的哈希函数。

## 什么是分区、分表、分库

分区
就是把一张表的数据分成N个区块，在逻辑上看最终只是一张表，但底层是由N个物理区块组成的

分表
就是把一张表按一定的规则分解成N个具有独立存储空间的实体表。系统读写时需要根据定义好的规则得到对应的字表明，然后操作它。

分库
一旦分表，一个库中的表会越来越多

## 什么是数据分片

数据分片
在分布式存储系统中，数据需要分散存储在多台设备上，数据分片（Sharding）就是用来确定数据在多台存储设备上分布的技术。数据分片要达到三个目的：

1. 分布均匀，即每台设备上的数据量要尽可能相近；
2. 负载均衡，即每台设备上的请求量要尽可能相近；
3. 扩缩容时产生的数据迁移尽可能少。

数据分片方法

1. 划分号段
   把Key为[1, 10000]的数据放在第一台设备上，把Key为[10001, 20000]的数据放在第二台设备上。
2. 取模
   这种方法先计算Key的哈希值，再对设备数量取模（整型的Key也可直接用Key取模）
3. 检索表
   在检索表中存储Key和设备的映射关系，通过查找检索表就可以确定数据分布，这里的检索表也可以比较灵活，可以对每个Key都存储映射关系，也可结合号段划分等方法来减小检索表的容量。
4. 一致性哈希
   一致性哈希的算法简单而巧妙，很容易做到数据均分布，其单调性也保证了扩缩容的数据迁移是比较少的。

## 数据模型的优化

数据依赖极小化
确定关系模式属于第几范式
对某些模式进行合并与分解
对关系模式进行必要分解
    1. 水平分解
        把经常使用的数据分解出来，形成一个子关系
    2. 垂直分解
        把经常一起使用的属性分解出来形成一个子关系模式

## 数据库物理设计的内容

为关系模式选择存取方法
    1. B+索引
       1. **查询**条件经常出现
       2. 聚集函数的参数经常出现
       3. **连接**操作的连接条件中经常出现
    2. Hash索引
       1. 等值连接或等值比较
       2. 大小可预知，且不变
    3. 聚簇 不适合于需要全表扫描的和更新次数多的
       使用 order by group by union distinct 时特别有利
       1. 经常进行**连接**的
       2. 查询**等值比较**
       3. 重复率很高，且分布平均

设计关系、索引等物理存储结构

## 数据库运行于维护工作

数据库转储和恢复 防止故障
数据库安全性、完整性控制
数据库性能监督、分析和改造
数据库重组织和重构造
    1. 重组织：不修改原设计的逻辑和物理结构，只重新安排存储位置、回收垃圾、减少指针链
    2. 重构造：修改模式和内模式

## 数据库查询处理过程

1. 查询分析
   1. 词法分析
   2. 语法分析
2. 查询检查
   1. 语义分析
   2. 试图消解
   3. 符号名转换
   4. 安全性检查
   5. 完整性初步检查
3. 查询树（语法分析树）转换为关系代数表达式
4. 查询优化
   1. 代数优化
      1. **选择**运算应尽可能先做；
      2. 把**投影**运算和**选择**运算同时进行；
      3. 把**投影**同其前或其后的双目运算结合起来执行；
      4. 把某些**选择**同在它前面要执行的笛卡儿积结合起来成为一个连接运算；
      5. 找出公共子表达式；
   2. 物理优化
      1. 基于规则的启发式优化
         1. 主码索引
         2. 等值查询-比例较小索引扫描否则全表
         3. 范围查询-比例较小索引扫描否则全表
         4. 连接-已排好序-排序-合并算法
         5. 连接-有索引-索引连接
         6. 连接-表小-hash join
         7. 连接-循环嵌套-小表作为外表
      2. 基于代价估算的优化
      3. 两者结合优化方法
5. 查询执行（代码生成器）

## 连接操作的实现方式

1. 嵌套循环算法
2. 排序-合并算法
3. 索引连接
4. Hash连接

## 查询计划的执行

分类：

1. 自顶向下
    从查询树的顶端发出请求，要求执行下方查询
2. 自底向上
   叶节点执行，放入缓冲区，等待父节点取走，然后继续执行

## 数据库管理系统层次

1. 应用层
2. 语言处理层
   1. 解释方法
   2. 预编译方法（装载模块和应用规划）
3. 数据存取层
4. 数据存储层
5. 操作系统
6. 数据库

## 关系数据库存取路径的组织

存取路径的组织和数据是分离的，对用户是隐蔽的，可以动态建立与删除，采用B+树或Hash文件结构，建立十分灵活。

## 并行数据库

实现数据库查询并行化的数据流方法
物理组织，并行地读写多个磁盘进行查询处理，充分发挥IO地并行性
并行算法地提出，sort-merge, hash-join等算法
查询优化

## 大数据定义

无法在可容忍的时间内用现有的IT技术和软硬件工具对其进行感知、获取、管理、处理和服务的数据集合

## 大数据的特征

Volume 巨量
Variety 多样
Velocity 快变
Value 价值

## 数据仓库定义

数据仓库是为了构建新的分析处理环境而出现的一种数据存储和组织技术
数据仓库是一个用以更好地支持企业决策分析处理的、面向主题的、集成的、不可更新的、随时间不断变化的数据集合。

特征：

1. 数据面向主题进行组织的
2. 是集成的，在进入数据仓库之前必须进行加工和集成
3. 不可更新
4. 数据仓库是随时间变化的，有淘汰，有新增

## 多维数据模型

数据分析时用户的数据视图，是面向分析的数据模型，用于给分析人员提供多种观察的视角和面向分析的操作
事实表、维表

## 数据挖掘的概念

从大量数据中发现并提取隐含在内的、人们事先不知道的但又可能有用的信息和只是的一种技术
目的是帮助决策者寻找数据间潜在的关联，发现经营者忽略的要素，这些要素对预测趋势、决策行为是十分有用的信息

与传统分析方法的区别:
数据挖掘是在没有明确假设的前提下去挖掘信息、发现知识，事先未知、有效、可实用

功能：
归纳总结数据的某些特征
找出多个变量之间取值的关联性
分类和预测
聚类
鼓励点检测
趋势和演变分析

## BI系统的变化

数据量急剧增长
数据类型多样
决策分析复杂
底层硬件环境变化

## BI三大支柱

数据仓库 Data Warehouse
联机分析处理 Online Analysis Processing
数据挖掘 Data Mining

## 什么是索引，B树索引结构，适合什么样的查询

索引是对数据库表中一个或多个列的值进行排序的结构，可以加快查询速度，快速定位到需要查询的内容。
B+树索引将索引属性组织成B+树的形式，B+树的叶节点为属性值和相应的元祖指针，能够动态平衡。B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）
适合相同属性值比例小，属性域较为分散，范围查询和单值查询

## 集中式数据库和分布式数据库谁的效率高，特征和应用场景，适合的应用

集中式

特征与应用场景：

集中式：集中式计算机网络由一个大型的中央系统，其终端是客户机，数据全部存储在中央系统，由数据库管理系统进行管理，所有的处理都由该大型系统完成，终端只是用来输入和输出。终端自己不作任何处理，所有任务都在主机上进行处理。
高一致性与可维护性

分布式：
每台计算机可单独放在一个地方，每台计算机中都可能有DBMS的一份完整拷贝副本，或者部分拷贝副本，并具有自己局部的数据库，位于不同地点的许多计算机通过网络互相连接，共同组成一个完整的、全局的逻辑上集中、物理上分布的大型数据库
分布式数据库系统的结构符合部门分布的组织结构，允许各个部门对自己常用的数据存储在本地，在本地录入、查询、维护，实行局部控制．由于计算机资源靠近用户，因而可以降低通信代价，提高响应速度，使这些部门使用数据库更方便更经济。

适合的应用：

集中式:
需要高一致性，并通过存储的冗余和软硬件结合的高度优化，达到了较高的可靠性

分布式：
大型应用，电商、金融、O2O、零售、社交应用等行业，普遍存在用户基数大、营销活动频繁、
物联网数据，传感监控设备多，采样频率高，数据规模大，会产生超过单机数据库存储能力极限的数据
文件索引，大量的图片、文档、视频数据，数据量都在亿级~万亿级。

## 树状数据构建关系模型的方式

邻接表 定义id和parent id实现
枚举路径 采用parent id/ chind id 类似文件路径的方式组织varchar
嵌套集 对树进行后根遍历，并按序标号，左侧的数值小于后代左侧的值，右侧的数值大于后代右侧的值
闭包表 新建TreePaths表存储了所有祖先-后代的关系的记录，含有祖先-后代两个属性

## 数据库锁机制和多种锁类型

因为数据库中的事务是具有隔离性的，一个事务的运行不应该影响另一个事务的运行。 但是因为并行机制的存在，会有一系列的问题。丢失更新。读脏数据，不可重复读，要有一定的隔离机制来满足数据库并行速度和操作正确性的需求，锁机制包含：一次封锁法，顺序封锁法，两阶段锁协议，时间戳排序协议
数据库为了保证数据的一致性，而使各种共享资源在被并发访问变得有序所设计的一种规则，锁的

类型：

排他锁
当一个事务执行insert、update或delete语句时，数据库系统会自动对SQL语句操纵的数据资源使用独占锁，独占锁不能和其他锁兼容，如果数据资源上已经加了独占锁，就不能再放置其他的锁了。

共享锁
当一个事务执行select语句时，数据库系统会为这个事务分配一把共享锁，来锁定被查询的数据，如果数据资源上放置了共享锁，还能再放置共享锁和更新锁。

意向锁
如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁；对任一结点加锁时，必须先对它的上层结点加意向锁。

更新锁
更新锁在的初始化阶段用来锁定可能要被修改的资源，这可以避免使用共享锁造成的死锁现象。更新锁与共享锁是兼容的，也就是说，一个资源可以同时放置更新锁和共享锁，但是最多放置一把更新锁。

## 什么时候需要手工干预锁

beginTranse(开启事务)
try{
    $result = $dbca->query('select amount from s_store where postID = 12345');
    if(result->amount > 0){
        //quantity为请求减掉的库存数量
        $dbca->query('update s_store set amount = amount - quantity where postID = 12345');
    }
}catch($e Exception){
    rollBack(回滚)
}
当前有三个用户a、b、c三个用户进入到了这个事务中，这个时候会产生一个共享锁，所以在select的时候，这三个用户查到的库存数量都是4个，同时还要注意，mysql innodb查到的结果是有版本控制的，再其他用户更新没有commit之前(也就是没有产生新版本之前)，当前用户查到的结果依然是旧版本；

然后是update，假如这三个用户同时到达update这里，这个时候update更新语句会把并发串行化，也就是给同时到达这里的是三个用户排个序，一个一个执行，并生成排他锁，在当前这个update语句commit之前，其他用户等待执行，commit后，生成新的版本；这样执行完后，库存肯定为负数了。

## 适用于内存和外存的数据结构

内存：随即存储特性，Hash 二叉搜索树、多维数组、广义表、红黑树都适用于内存
外存：顺序读写特性，B+树减少IO次数

## 好的模式分解具有的性质

无损连接性和依赖保持性
**函数依赖保持性**：设p={R1<U1，F1>,R2<U2，F2>,···,Rn<Un,Fn>}是关系模式R{U,F}上的一个分解。若∪Fi  =F ，则称分解p具有函数依赖保持性。
**无损连接性**：设p={R1<U1，F1>,R2<U2，F2>,···,Rn<Un,Fn>}是关系模式R{U,F}上的一个分解。若任何属于R{U,F}的关系r，令r1=πR1(r)，r2=πR2(r)，···，rn=πRn(r)，有r=r1∞r2∞···∞rn成立，则称分解p具有无损连接性。

## 创建索引时需要考虑的

1. 表的主键、外键必须有索引；
2. 数据量超过300的表应该有索引；
3. 经常与其他表进行连接的表，在连接字段上应该建立索引；
4. 经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；
5. 在经常需要根据范围进行搜索的列上创建索引
6. 索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；
7. 频繁进行数据操作的表，不要建立太多的索引；
8. 为经常出现在关键字order by、group by、distinct后面的字段，建立索引。
9. 对于那些在查询中很少使用或者参考的列不应该创建索引。
10. 不要在有大量相同取值的字段上，建立索引。
11. 对于那些定义为text, image和bit数据类型的列不应该增加索引。
12. 当修改性能远远大于检索性能时，不应该创建索引。当增加索引时，会提高检索性能，但是会降低修改性能。

## 什么是倒排索引

倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。
倒排索引源于实际应用中需要根据属性的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引(inverted index)。带有倒排索引的文件我们称为倒排索引文件，简称倒排文件(inverted file)。

## 填空

数据模型包括，数据结构，数据操作，数据完整性约束条件。从应用层区分，可分为概念模型，逻辑模型，物理模型，主要的数据模型是，层次模型，网状模型，关系模型

事务的四个特性是原子性，一致性，隔离性，持久性。

关系分解的两个原则是无损连接性，保持函数依赖性。

关系模型的所运用的数学运算是关系代数，关系演算。

E-R 图合并时，分E-R 图会碰到的冲突是：属性冲突，命名冲突，结构冲突。

等级日志的原则

1. 登记的次序严格按并发事务执行的时间次序。
2. 必须先写日志文件在，后写数据库。

因为把对数据的修改写入数据库和把表示这个修改的日志记录写到日志文件中是两个不同的操作，有可能在这两个操作之间发生故障。如果先写了数据库修改，而在运行记录中没有登记这个修改，以后就无法恢复这个修改了。若先写日志，但没有修改数据库，按日志文件恢复时只不过是多执行一次不必要的 UNDO 操作，并不会影响数据库的正确性。所以为了安全，一定要先写日志文件，即首先把日志记录写到日志文件中，再写数据库的修改。这就是“先写日志文件”的原则

## 计算最小依赖集

1. 右侧化为单一元素
2. 去掉左部多余属性
3. 一个个去掉，用剩余条件看左侧能否推出右侧

## 计算候选码

1. 求只在左边出现和两边都不出现的属性的闭包，如果包含所有属性，则为唯一候选码
2. 加入1个两侧都出现过的属性（都尝试一遍），求闭包，如果包含所有属性，则为候选码
3. 加入2个两侧都出现过的属性（都尝试一遍），求闭包，如果包含所有属性，则为候选码
4. 加入n个两侧都出现过的属性（都尝试一遍），求闭包，如果包含所有属性，则为候选码

## 函数依赖集分解

分解到3NF，保持函数依赖：

1. 化到最小依赖集
2. 按照左侧相同的分组
3. 去掉包含关系，被包含的

分解到3NF，并保持无损连接

在上面的基础上：

1. 加上可以确定所有属性的码
2. 是否有包含码或者被码包含的，去掉

分解到BCNF：

1. 化到最小依赖集
2. 找到当前的码
3. 找到第一个依赖，其左侧不是码，将这个依赖集作为左子树
4. 右子树为去掉这个依赖的右侧属性后的，并重新计算此时的最小依赖集，转2

## 判断一个函数依赖集属于什么范式

1. 按照L, R, LR找到候选码
2. 判断是否存在非主属性对码的部分、传递函数依赖，主属性对码的部分、传递函数依赖

## 解释事务、程序，和他们的区别

事务：事务是DBMS的基本工作单位，它是用户定义的一个数据库操作序列。它是一个不可分割的工作单位，这些操作要么都执行，要么都不执行。
程序：指示计算机每一步动作的指令，通常用某种程序设计语言编写，运行于某种目标体系结构上。
区别：事务是不能分割的，而程序运行中程序执行的指令可以只执行一部分，一个程序中通常有多个事务

## 完整性约束的含义和内容

完整性约束的含义：数据的正确性和相容性，即数据符合现实世界语义，反应当前实际情况，数据库中同一对象在不同关系表中的数据是符合逻辑的
实体完整性
参照完整性
用户定义完整性

## 排它锁，共享锁，死锁，活锁

排它锁：若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何锁，知道T释放A上的锁。
共享锁：若事务T对A加上S锁，则只允许T读取A，但不能修改A，其他事务可以再对A加S锁，当不能加X锁，直到T释放S锁为止。
死锁：若两个事务T1，T2占有各自的资源，并持续等待只能由对方事务释放的资源而陷入无限等待的情况
活锁：若某一事务T请求封锁对象A时，由于系统的调度策略导致总有其他事务获得资源，而T一直等待

## 什么时候可以不遵守范式

一个完全按照范式设计的冗余极低的数据库，很可能在性能上会输给冗余相对多一些的数据库
反范式，最典型的就是在一些数据表中不仅存作为外键的user_id,同样存user_name,这样虽然违反数据库范式增加了user_name字段，但是却提高了效率，减少了获取user_id后再去user表中获取user name的操作

## SQL 有什么优化策略。从硬件、系统、应用各级分析

硬件：
增加内存加大可缓存的数据量
提高单个磁盘性能，组成磁盘阵列，提高存储自身以及存储和主机之间的带宽
提升CPU处理能力，增加 CPU 数目
通过万兆交换机来替换现在常用的千兆交换机来提升网络处理能力降低网络延时

系统：
代数优化

1. **选择**运算应尽可能先做；
2. 把**投影**运算和**选择**运算同时进行；
3. 把**投影**同其前或其后的双目运算结合起来执行；
4. 把某些**选择**同在它前面要执行的笛卡儿积结合起来成为一个连接运算；
5. 找出公共子表达式；

物理优化

1. 基于规则的启发式优化
    1. 主码索引
    2. 等值查询-比例较小索引扫描否则全表
    3. 范围查询-比例较小索引扫描否则全表
    4. 连接-已排好序-排序-合并算法
    5. 连接-有索引-索引连接
    6. 连接-表小-hash join
    7. 连接-循环嵌套-小表作为外表
2. 基于代价估算的优化
3. 两者结合优化方法

应用：
要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。
应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描
尽量避免在 where 子句中使用 != 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫描。
尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描
尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描
尽量使用数字型字段
尽量避免大事务操作，提高系统并发能力。
尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。
将运算尽可能从数据库端迁移到应用端，降低数据库主机的计算量

## 大数据和BI数据分析有什么不同，应用大数据的场景、来源、技术架构。

BI(BusinessIntelligence)即商业智能，它是企业数据化管理的一整套的方案，用来将企业中现有的数据进行有效的整合，快速准确的提供报表并提出决策依据，帮助企业做出明智的业务经营决策，解决的是管理运营战略的问题。

大数据(Big Data)是指在可承受的时间范围内用常规软件工具进行捕捉、管理和处理的数据集合，是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力来适应海量、高增长率和多样化的信息资产。大数据侧重于解决某一类问题的方法，比如全网用户画像，对网络、传感器等非结构化海量数据的分析。

**BI**更倾向于决策，对事实描述更多是基于群体共性，帮助决策者掌握宏观统计趋势，适合经营运营指标支撑类问题，**大数据**则内涵更广，倾向于刻画个体，更多的在于个性化的决策。

场景：
医疗、金融、零售、电商、交通、教育、航天

来源：
第一类：从来源来看分为内部数据和外部数据；
第二类：从结构来看分为非结构化数据和结构化数据；
第三类：从可变性来看分为不可变可添加数据和可修改删除数据；
第四类，从规模来看分为大量数据和小量数据。

技术架构：
Apache Hadoop是一种专用于批处理的处理框架。包含多个组件，通过配合使用可处理批数据：

· HDFS：HDFS是一种分布式文件系统层，可对集群节点间的存储和复制进行协调。HDFS确保了无法避免的节点故障发生后数据依然可用，可将其用作数据来源，可用于存储中间态的处理结果，并可存储计算的最终结果。

· YARN：YARN是Yet Another Resource Negotiator（另一个资源管理器）的缩写，可充当Hadoop堆栈的集群协调组件。该组件负责协调并管理底层资源和调度作业的运行。通过充当集群资源的接口，YARN使得用户能在Hadoop集群中使用比以往的迭代方式运行更多类型的工作负载。

· MapReduce：MapReduce是Hadoop的原生批处理引擎。

批处理模式
Hadoop的处理功能来自MapReduce引擎。MapReduce的处理技术符合使用键值对的map、shuffle、reduce算法要求。基本处理过程包括：

· 从HDFS文件系统读取数据集
· 将数据集拆分成小块并分配给所有可用节点
· 针对每个节点上的数据子集进行计算（计算的中间态结果会重新写入HDFS）
· 重新分配中间态结果并按照键进行分组
· 通过对每个节点计算的结果进行汇总和组合对每个键的值进行“Reducing”
· 将计算而来的最终结果重新写入 HDFS

存储框架
HDFS——分布式文件存储系统（HADOOP中的存储框架）
HBASE——分布式数据库系统
KAFKA——分布式消息缓存系统(实时流式数据处理场景中应用广泛)

运算框架：（要解决的核心问题就是帮用户将处理逻辑在很多机器上并行）
MAPREDUCE—— 离线批处理/HADOOP中的运算框架
SPARK —— 离线批处理/实时流式计算
STORM —— 实时流式计算

## 关系模型的一致性

只要遵守关系理论，可以保证基于数据库的任何查询结果与原始数据具有同样的有效性
关系理论包括

1. 关系不包含重复数据
2. 记录之间没有顺序

## 规范化的价值

合理规范化的模型可应对需求变更
规范化数据重复降至最少

## 分布式数据系统复杂性大大增加

无法从数据规划中获益（物理结构，索引）
Copy的数据传输开销
不同数据源数据结合极为困难
远程数据的透明引用访问代价很高

## 数据库该如何部署呢？

中庸、分析、决策

## AA

除了分区和DBMS已知的临时表之外，在应用程序中使用DDL建立、修改或删除数据库对象，是很差的方式。

数据字典是所有数据库操作的中心，任何对数据字典的操作都会引起全局加锁，对系统性能影响巨大。

## 进攻式编程的本质特征

以合理的可能性为基础
类似DBMS采用的乐观并发控制
乐观的方法比悲观的方法的吞吐量高的多

## 系统生产序列号，远好于

寻找当前最大值并加1
用一个专用表保存”下一个值“且加锁更新

## 但如果插入并发性过高，在主键索引的创建操作上会发生十分严重的资源竞争

逆向索引
哈希索引

## 没有使用我的索引

使用B+树索引，而且谓词中没有使用索引的最前列
使用SELECT COUNT(*) FROM T，而且T上有索引，但是优化器仍然全表扫描
对于一个有索引的列作出函数查询
此时如果用了索引，实际反而会更慢
没有正确的统计信息，造成CBO无法做出正确的选择

## 避免在最高层使用 distinct 应该是一条基本规则

原因在于，即使我们遗漏了连接的某个条件， distinct 也会使查询看似正确地执行
无可否认，发现重复数据容易，发现数据不准确很难

## 索引组织表 index-organized table IOT

对IOT表插入的效率也许低于堆文件
IOT的用途：全索引表，代码查找表，高频度的一组关联数据查询
IOT最大的优点：记录是排序的（效率惊人）
堆组织表的数据是散放的，索引和表的数据是分离的。会使用段中找到的第一个能放下此数据的自由空间。当从表中删除数据时，则允许以后的INSERT和UPDATE重用这部分空间。它是以一种有些随即的方式使用。
索引组织表的索引和数据是在一起的
堆组织表的存储速度因为不用考虑排序, 所以存储速度会比较快. 但是要查找符合某个条件的记录, 就必须得读取全部的记录以便筛选.
索引组织表有一个可变的主B树存储组织。不象普通表(堆组织),数据是无序存储的集合。索引组织表是以主键排序的方式的B树组织结构。
heap table 就是一般的表，获取表中的数据是按命中率来得到的。没有明确的先后之分，在进行全表扫描的时候，并不是先插入的数据就先获取。数据的存放也是随机的，当然根据可用空闲的空间来决定。
而iot 就是类似一个全是索引的表，表中的所有字段都放在索引上，所以就等于是约定了数据存放的时候是按照严格规定的，在数据插入以前其实就已经确定了其位置，所以不管插入的先后顺序，它在那个物理上的那个位置与插入的先后顺序无关。这样在进行查询的时候就可以少访问很多blocks，但是插入的时候，速度就比普通的表要慢一些。

## 分区是一种数据分组的方式

提高并发性（concurrency）和并行性（parallelism）
从而增强系统架构的可伸缩性（scalable）

## 循环分区：不受数据影响的内部机制

分区定义为各个磁盘的存储区域
可以看作是随意散布数据的机制
保持更改带来的磁盘I/O操作的平衡

## 数据驱动分区

是根据一个或多个字段的值来定义分区，每条记录插入相应的分区。多数非常大的表是因为它包含了历史数据，最常查询的是那些较新的数据，我们可以根据日期进行分区，把常用数据和不常用数据分别放在不同的分区中

## 分区键(partition key)

该键决定记录将被保存在哪个分区，利用分区视图的所有优势，即在操作表时具有透明性，而且可以把保证数据完整性的任务交回给DBMS

## 分区的实现方式

范围分区（Range-partitioning）根据连续数据的范围对数据进行分组。范围分区非常适合处理历史性数据，同之前讨论的分区视图概念最为接近
列表分区（List-partitioning）最具手工风格的分区类型，适合定制解决方案，必须明确指定分区键的可能取值以及每种键值对应的分区
哈希分区（Hash-partitioning）对分区键进行hash运算，根据结果分区。完全基于hash运算的结果，完全不考虑数据值的分布。哈希分区能保证根据分区键快速找到记录，但对范围搜索没有优势，因为hash函数会将连续的键值转换为非连续的hash值，再根据hash值确定物理地址

## 分区是把双刃剑

一方面，它通过分区键将数据聚集在一起，利于高速检索。
对于并发执行的操作，分散数据可以避免访问过于集中的问题。
尽量以紧凑的方式存储数据，这有助于查询尽快找到所有数据。
另一个目标是尽量将数据分散存储，以便多个线程可以并发写入，不会造成资源争用而互相妨碍

## 在数据库设计中，树通常三种模型

Adjacency model-邻接模型
Materialized path model-物化路径模型
Nested set model-嵌套集合模型

## Physical Database Design Methodology

Translate logical database design for target DBMS
Choose file organizations and indexes
Design user views
Design security mechanisms
Consider introduction of controlled redundancy
Monitor and tune operational system

## 锁的粒度

整个数据库
要修改的表
包含受影响数据的记录
记录中的字段
存储被修改的表的那部分物理单元
包含目标数据的的块和页

## 尽可能避免SQL语句上的循环处理

尽量减少程序和数据库之间的交互次数
充分利用DBMS提供的机制，使跨机器交互的次数降

## 资源竞争

DBA解决方案
事务空间（Transaction space）
可用列表（Free list）

架构解决方案
分区（Partitioning）
逆序索引（Reverse index）
索引组织表（Index organized table）

开发解决方案
调节并发数
不适用系统产生值

数据仓库一定是非规范化的
操作型数据的存储和决策支持系统

## 使用SQL需要考虑的因素

定义结果集所需的查询条件
过滤条件的效率有高有低，尽早过滤不需要的数据

结果集的大小
努力使响应时间与返回记录数成正比，因为用户的耐心很大程度上与预期返回的记录条数有关

获得结果集所需访问的数据量
访问1000行的表和1000万的表可能需要不同的查询方案，没有确定目标容量之前，很难断定查询执行的效率

获得结果集所涉及的表的数量
当需要连接多个表时，按常理应该质疑设计的正确性。虽然现代的DBMS都能非常高效地连接很多表，但对优化器来说，表数量的增加，复杂度将呈指数增长

同时修改这些数据用户的多少
并发性是必须认真对待的因素，一般而言我们必须考虑系统的整体吞吐量，而不是个别用户的响应时间

## 并发用户数很大的系统

尽量以紧凑的方式存储数据
尽量将数据分散存储

## 没有并发的修改密集型

数据查询要快
数据更新也要快


原子性有两个优点：

1.高效搜索的能力，因为常规索引通常以具有原子性的值作为键
2.从数据库角度保证数据的正确性

约束应明确声明

数据中存在隐含约束是一种不良设计，隐含约束通常只有人知道，但DBMS不知道，不能帮助优化器实现最高效的数据访问。应当尽可能多地定义约束，约束不仅有助于保证数据完整性，还为DBMS优化器提供了数据的重要信息

## 高效访问数据库

查询识别
减少于数据库交互的次数
大局上跳出业务逻辑的限制
保持schema稳定
慎用自定义函数
数据库负载符合业务逻辑的特性
进攻式编程

## 索引设计

作为复合索引的第一个字段，也没有必要单独加索引
无论如何都不需要对一个字段建立两个索引

当索引已含有其它信息时，就没必要再访问它所指的原始数据，在索引中加入额外的字段，就能提高某个频繁运行的查询的速度，这是因为查询所需要的数据可以全部从索引中获取，而完全不必再访问原始数据源

## SQL注入

而是以'?'做为占位符，采用SQL预编译的形式，一方面数据库会缓存预编译的SQL，便于重复使用提高性能，另一方面可以避免SQL注入的漏洞

## 对合理分区的部分进行大范围扫描

反而会比使用索引协助检查范围边界值更高效。当然，分区并不能解决所有大数据量的问题，分区必须注意分区键的分配均衡，数据范围的边界，包括上限和下限必须明确定义

## 影响查询性能真正的重要因素包括

查询条件的质量
结果集的大小
表的数量
表有哪些索引
存储特性，分区、索引
